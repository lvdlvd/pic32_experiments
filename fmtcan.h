#pragma once

#include <stddef.h>
#include <stdint.h>

/** can_fmt writes a CAN message to the buffer buf in quasi readable format as
 *
 * 		ID-A['.' ID-B]['R'][':' aabbccddeeffgghh] NUL
 *
 * ID-A is the hexadecimal representation of ID-A[10:0], so 000 .. 7ff.
 * The dot '.' is present if the header is the extended 29 bit format.
 * ID-B is a hexadecimal representation of ID-B[17:0].
 * 'R' is present if the RTR bit is set.
 * The colon ':' and up to 16 nibbles represent len bytes from the payload
 * pointer in network order.
 * NUL is the ASCII character 0x0
 *
 * can_fmt will not write more than sz bytes to the output buffer. A buffer
 * of 27 bytes will always be large enough to hold the encoding including
 * the terminating NUL.
 *
 * header must be a valid encoding of id-a, id-b and the RTR bit as produced by
 * can_header() or can_header_ext()
 *
 * On success, can_fmt returns the total number of bytes actually written to buf.
 *
 * if the buffer is too small to write the entire string (including the terminating NUL),
 * can_fmt returns zero, even though the contents of buf will be clobbered.
 *
 * if len > 8, can_fmt returns zero because CAN messages can only represent payloads
 * of length 0..8 inclusive.
 */
size_t can_fmt(char *buf, size_t sz, uint32_t header, size_t len, const uint8_t *payload);

/** can_fmt_crc writes a CAN message like can_fmt followed by a checksum.
 *
 *  ID-A['.' ID-B]['R'] ':' [xx...]':' crc16 NUL
 *
 *  The crc16 is computed over the bytewise representation of header and payload
 *  with the polynomial 0xc599, msb-first.  see can_crc16_next() in the fmtcan.c.
 *  this is not the same bit pattern as the crc on the bus defined in the CAN standard.
 */
size_t can_fmt_crc(char *buf, size_t sz, uint32_t header, size_t len, const uint8_t *payload);

/** can_scan reads a message in the format written by can_fmt from the provided buffer
 *
 * buf must start with the first hex digit of the message.
 * Scanning stops after sz bytes or before the terminating NUL or non hex digit, whichever comes first.
 * Instead of by a space, a valid message may be terminated by any non-alphanumeric character
 * after the ID-A, ID-B, 'R' or aabbb... parts of the message.
 *
 * All arguments must be non-null and non-zero.
 * Payload must be at least 8 bytes.  len will be set to the actual number decoded.
 *
 * An invalid message may clobber header, payload and len.
 *
 * If the message is valid returns the number of bytes read from buf, otherwise it returns zero.
 */
size_t can_scan(const char *buf, size_t sz, uint32_t *header, size_t *len, uint8_t *payload);

/** can_scan_crc reads the message with can_scan and the trailing :crc code.
 *
 * The arguments are like can_scan().  The checksum is expected to have been generated by can_fmt_crc().
 *
 * If the message is validly formatted and the checksum is valid, it returns the number of bytes read from buf.
 */
size_t can_scan_crc(const char *buf, size_t sz, uint32_t *header, size_t *len, uint8_t *payload);

#if 0
/** can_hdlc_encode writes a CAN message in a binary format suitable for transmitting
 * over a character stream, like an old-fashioned serial port or a unix stdout stream.
 *
 * header is encoded as a 16 or 32 bit  big endian uint, depending on the IDE flag, followed by up to
 * min(8, len) bytes of payload and 2 bytes of crc16. (Since the message is terminated by the
 * framing we don't need to encode lenght explicitly.)
 *
 * The entire message is HDLC-escaped and terminated with a HDLC flag (0x7e).
 * A buffer of 29 bytes will always be large enough to hold the worst case blown up frame.
 * Typically the encoding will take 5-15 bytes.
 *
 * On success, can_hdlc_encode returns the total number of bytes actually written to buf.
 * if the buffer is too small, can_hdlc_encode returns zero, even though the contents
 * of buf will be clobbered.
 */
size_t can_hdlc_encode(char *buf, size_t sz, uint32_t header, size_t len, const uint8_t *payload);

/** can_hdlc_decode reads a message in the format written by can_hdlc_encode from the provided buffer
 *
 * An invalid message will leave header == 0, but may clobber payload and len.
 * the returned value is the number of bytes consumed from buf[:sz]. if the next byte is not
 * the HDLC_FLAG
 */
size_t can_hdlc_decode(const char *buf, size_t sz, uint32_t *header, size_t *len, uint8_t *payload);

/** cancrc_next updates the crc with polynomial 0xc599.
 *
 * Used by can_hdlc_* and can_fmt_ but not compatible with the checksum
 * computed by the CAN standard on the CAN physical layer, because that takes
 * the bitpattern on the physical bus as input.
 */
uint16_t can_crc16_next(const uint16_t crc_in, uint8_t data);
#endif
